### Summary

I implemented buttons as a generic component with actions for pressed and released events. Buttons can be pushed or toggled and have an auto-reset timer. This goes with the interactive component to create items that can control other entities in the world without being picked up.

I added a cooldown component and system. When interactive entities have the cooldown component, interactions will not happen until the system counts down and removes the component.

I refactored actions to support more node types and have a more logical method signature: run/test are now (source, event, actor). I also added a remote action node that can connect two action trees, and an extra actions component for adding level-specific actions outside of prefabs.

I added support for entities with multiple physics bodies. The targeting code now checks the collider, collider's parent_entity field, then the collider's parent node. This fixes doors, which needed to have the static body as a child within the entity.

### Progress

- implemented buttons
	- somewhat generic component with actions for pressed and released events
	- goes with the interactive component to create items that cannot be picked up, but can control other entities in the world (open a door, unlock something, spawn zombies, etc)
	- buttons can be pushed or toggled
	- buttons can have an auto-reset timer
- moved health limits into health component
	- setting the current health will always clamp to the (0, max_health) range
- added an asset pack for particles and smoke
	- https://reactorcore.itch.io/particle-effect-texture-essentials
- added cooldown component and system
	- when interactive entities have the cooldown component, interactions will not happen
	- the system counts down each cooldown and removes the component when it expires
- refactored actions to support more node types and have a more logical method signature
	- run/test are now (source: Node, event: ActionEvent, actor: Node)
	- only actor can be null
- added remote action node
	- can be used to connect two action trees
	- use sparingly, can cause infinite loops
- added extra actions component
	- same as actions component in data
	- adds extra actions from the level or outside of the prefab
	- gods forbid we have to nest these
- added support for entities with multiple physics bodies
	- added a helper to the targeting code that will check the collider, collider's `parent_entity` field, then the collider's parent node
	- fixes doors, which needed to have the static body as a child within the entity

### TODOs

- [x] timeout/cooldown should be its own component with a system to expire them
- [x] helper to run actions
	- needs to run the target node if it is an action, otherwise run the children
	- does not need to be recursive for more than one level
- [x] node/component for extra actions
	- needs to support node links
	- needs to handle different events
- [x] update action signature for non-area triggers
	- timer, button, etc
- [x] rename trigger area and timer to action

- update the base action signature to replace trigger area with node and use the enum from enums
	- `(actor: Entity, source: Node[ActionTimer,ActionArea3D], event: Enums.Actions)`
	- not all sources are 3D - Timer f.ex
	- the actor will probably always be an entity
	- to support the current run_node and run_physics, there needs to be a fourth parameter
	- that fourth param is the node being acted upon and may be the same as actor
		- for area enter and exit, the target and actor are the same body that entered, while the source is the area itself (target == actor)
		- for button pressed, the target is the button and the actor is the entity pressing it (target == source)
		- for button release, the target and actor might both be null, while source is the button (target == actor)
	- for actor to be meaningful, it needs to be passed through parent entities into children
		- the actor when a barrel explodes is the last entity that damaged it
- update actions for the same
- figure out how to pass the actor in the first parameter
	- need to keep a reference for some delayed events

If you press a button, the player is the actor and the target is the button.
If you walk into an area, the area is the actor and the target is the player

(Source, action, actor)

Source is the button, area, or timer
Action is the enum
Actor is the player, physics body, or null

I took a shower and remembered that you fill in arguments from left to right. Source changes less than action, which changes less than actor, which can be null.

### Next Up

- [x] fix shotgun blocking selections
	- the shotgun model collides with the selection raycast, based on the probe shape
- add explosion decals
	- the raycast in the explosion effect needs to apply decals
	- may be multiple surfaces
- [x] add more door types
	- breakable
	- automatic sliding
	- cw + ccw pair
		- can't be a prefab, entity needs to be scene root
- [x] gimbal node that maintains its rotation on ready
    - rotation multiplier, defaults to 0 (fully locked)
    - action raycast
- [x] pressure plate trigger

### Level Actions

I've already run into a few occasions where an interactive entity needs to run actions that depend on other entities in the level that exist outside of the interactive prefab. The simplest example is a button that opens a door, which needs a door action linked to a door in the level, outside of the prefab scene.

For other components, I solved this by adding an extra_components field to the base entity, which are appended to the list before the ECS world instantiates the component resources.

There are a few complications:

- Since actions are nodes, they cannot be attached directly to a component, but the component can store a path to them
- Those node paths will be outside of the prefab scene
- Reusing the extra components list would be good
- Actions are more complicated because they run on events

Areas and timers could be entities if actions were a component.

#### Update

Even with actions as a component, the button now uses a set of prefab actions to play the sound and animation. Attaching the door actions as an extra component replaces those prefab actions, breaking the sound effect and animation for the button.

The simplest solution would be to add an ExtraActions or LevelActions component, which is considered after the regular Actions.

### Fixing Doors

The changes to support entities with multiple physics bodies broke doors.

- making the door entity into the root of its scene meant making the physics body a child of the entity
- most of the collision/interaction code relies on the entity being the physics body
- the physics body is reported by the collision/physics engine
- when the body is a child of the entity, collision does not work
- therefore, doors no longer work (although their scene structure is excellent)
- adding support for the body's parent would not be difficult, but might be slow
- checking the body's parent would allow entities with multiple physics bodies
- extending the physics body with an `EntityBody` script and then assigning the `entity` field would also work
