### Summary

I did a lot of menu cleanup today. Added the click sound to all menu buttons, dialogue responses, and progression. Made the quit buttons red again after adding sounds. Renamed the start menu to main menu (which is what I was calling it already). Added a parameter to the show_menu method to set the tab for tabbed menus.

I added new features: equipped items have slots and can be visible if their slot is visible, with characters having different slots attached to 3D markers. The player's flashlight uses a model and moves with their hands. I added grass clusters to the fishing pier beach.

I added new nodes: a physics body with controllable buoyancy that uses a central force to adjust position so it works with collision, and a light group that enables or disables a group of lights.

I fixed the screen effect areas getting stuck issue. The relationships that enable screen effects were not being removed after leaving the area. The code was applying a new relationship every time on the body interval but only removing one when you left. If you stayed for at least one interval, you'd end up with extra relationships. The fix was to remove-then-apply on each interval to keep them balanced.

I did playtesting with my partner and learned a few things: need to clarify pause menu exit/quit buttons, ramps and stairs are not walkable since changing the character controller, stamina usage bugs, and player does not reset on new game. Most of these were fixed by adjusting the IKCC walkable slope to 50 degrees and clarifying the button labels.

### Progress

- some menu cleanup:
	- added the click sound to all menu buttons
	- added the click sound to dialogue response buttons
	- added the click sound to dialogue progression
	- added the click sound to the tabs in the options menu
	- make the quit buttons red again after adding sounds
	- move dialogue response buttons to a better location
		- no longer over the dialogue line panel
	- renamed the start menu to the main menu (which is what I was calling it already)
	- added a common signal for menus that need to exit the game
		- the exit call is handled in the combined menu scene, with confirmation dialog logic
	- defined a list of menus where the exit dialog will not appear:
		- game over
		- main menu
		- exit dialog itself
	- added a parameter to the `show_menu` method to set the tab for tabbed menus
		- only works with the options menu today
		- used for the controls shortcut button in the pause menu
- new features:
	- equipped items have slots and can be visible if their slot is visible
		- characters can have different slots, attached to 3D markers
	- the player's flashlight uses a model and moves with their hands
		- will be an equipment item soon
	- added grass clusters to the fishing pier beach
		- testing a method of mixing a grass texture with a foliage mask to create a wider variety of sprites
- new nodes:
	- physics body with controllable buoyancy
		- has a flag to enable/disable (when killed, out of water, etc)
		- has buoyancy and damping strength
		- you can specify a target height (Y position) to maintain or use the Node3D's starting position
		- you can set a max velocity for the buoyancy force
		- uses a central force to adjust the position, so it works with collision and the rest of the physics world
		- cannot be applied to ECS entities yet, only for props
	- light group
		- enables or disables a group of lights
- misc:
	- rename the editor tool buttons to more clearly indicate what they do
	- rename the response menu script class to resolve a duplicate script name error

### TODOs

- [x] add credit header to dialogue scripts
- [x] fork dialogue response menu script to instantiate the audio button scene for each response
- [x] play sound when changing tabs
- [x] make quit buttons red again
- [x] clarify exit vs quit buttons
	- exit opens a dialog that leads to the main menu or quitting
	- quit closes the game
- [x] rename start menu to main menu
- [x] move quit handler back into main menu
- [x] move dialogue responses to a better location
- [x] sound effect when moving to next dialogue screen
- [x] add volume slider for menu background sounds
- [x] add a floating object to the ocean in the fishing pier level
- [x] adjust the height of the water area in the fishing pier level to match the player's head height
- [x] disable buoyancy when things are out of the water (could be an active distance range or an area that enables/disables the effect)
- [x] shotgun flash it needs a light
- [x] Flashlight models need to be visible
	- [x] the flashlight should either move with the hands or the weapon (could be an option)
	- ~~light group could be a component~~
- [x] visible inventory items or equipped items
	- [x] the inventory node should not be visible, to hide your "backpack" items
	- [x] if equipping items uses a slot system, each slot will need a marker
- [x] add options to main menu
- [x] possibly add controls as well

### Next Up

- [x] make the oil puddle more shiny
- [x] use meshes for the crates
- [x] add a rave gun
	- [x] shoots glitter with an RGB gradient light
	- [x] the blast effect has a random colored light
- [x] add a hat to every level
    - [x] pirate or sailor or fish hat in fishing pier level
    - [x] traffic cone hat in bus stop level, near dumpster
- [x] add flying birds to the fishing pier
    - [x] with occasional sounds
- [x] convert flashlight into an equipment item and slot
- [x] use equipment slots for weapons
- [x] fix the killed by name to be the interactive name of the entity, not the node name

### Making Buttons Click

For regular buttons, this was easy: set up a button scene with audio, write a little script to connect them, and then use that in place of each button in the menus.

![[Pasted image 20251231111835.png]]

The script is very brief:

```
extends Button
class_name AudioButton


@export var audio_stream: AudioStreamPlayer


func _ready() -> void:
	pressed.connect(_pressed)


func _pressed() -> void:
	if audio_stream != null:
		audio_stream.play()
```

I want to look into using a single, shared audio player node as a future optimization, or having a click signal that can be emitted.

But for the dialogue menu, this was harder. The dialogue menu has its own input handling that doesn't fire the pressed event on the response buttons, so the script was only running the ready handler, never the pressed handler. The culprits were these two event handlers in the responses menu script:

```
func _on_response_mouse_entered(item: Control) -> void:
	if "Disallowed" in item.name: return

	item.grab_focus()


func _on_response_gui_input(event: InputEvent, item: Control, response) -> void:
	if "Disallowed" in item.name: return

	if event is InputEventMouseButton and event.is_pressed() and event.button_index == MOUSE_BUTTON_LEFT:
		get_viewport().set_input_as_handled()
		response_selected.emit(response)
	elif event.is_action_pressed(&"ui_accept" if next_action.is_empty() else next_action) and item in get_menu_items():
		get_viewport().set_input_as_handled()
		response_selected.emit(response)
```

Because the mouse entered event was used to set focus and then mouse buttons were handled directly, this emitted the `response_selected` signal without ever pressing the button control.

My first attempt to fix this used as an `if item is Button` check to emit the pressed signal if the input control was a button, which worked when you stepped through it in the debugger, but didn't work when the game was running normally because the buttons were removed too soon. This is a good example of where a shared sound node that was attached to the main menu could be helpful, because it would not be removed.

Luckily, the audio button was already set up so that you could customize its audio player and the menu click had already been extracted into its own scene, so I was able to attach all of the responses to a single click sound node, which existed as long as the dialogue menu was open. This fixed the sounds for the dialogue menu responses, but moving on to the next line of dialogue still needs some kind of confirmation sound.

### Screen Effect Areas Getting Stuck

I've seen an occasional issue where screen effect areas were getting stuck and the effect was not turning off after you left the area.

It did not take long to confirm this was a problem within the ECS world. The relationships that enable the screen effects were not being removed after leaving the area, although they would typically not stack either (a second one would appear if you reentered the area, but leaving would remove it and you would be back to one effect relationship again).

After looking at the event handlers, I found this likely culprit:

```
func _apply_effect(body: Node) -> void:
	if body.has_component(ZC_Player):
		var body_effect := effect.duplicate()
		body.add_relationship(RelationshipUtils.make_effect(body_effect))


func _remove_effect(body: Node) -> void:
	if body.has_component(ZC_Player):
		body.remove_relationship(remove_query, 1)


func run_entity(_source: Node, event: Enums.ActionEvent, actor: Entity) -> void:
	match event:
		Enums.ActionEvent.BODY_ENTER:
			_apply_effect(actor)
		Enums.ActionEvent.BODY_EXIT:
			_remove_effect(actor)
		Enums.ActionEvent.BODY_INTERVAL:
			_apply_effect(actor)
```

This code would apply a new relationship for the effect every time the body entered or on the interval, but would only ever remove one of them. If you stayed in the area for at least one interval, you would end up with two relationships (one added when you enter, one added on the body interval).

This was easy to confirm by loading the debug level and staying in one of the screen effect areas for more than the 15 second body interval. After spending a few minutes there, I checked the debugger to find a whopping 51 relationships on the player and most of them were screen effects. That seems like too many for the time period, which might be worth looking into.

The fix was simple. In the `match event` statement, make sure there are an even number of apply and remove calls:

```
		Enums.ActionEvent.BODY_INTERVAL:
			_remove_effect(actor)
			_apply_effect(actor)
```

Adding this additional `_remove_effect` call keeps them balanced when you are standing in the area for long periods of time, but it does break effect curves that have a duration longer than the body interval, because it resets every few seconds. If that is a problem, the easiest workaround is to adjust the body interval to match the curve duration, so the full curve can play out before the effect resets. If there is still a visible blip, I can adjust the code to overlap them, but this remove-apply sequence should occur on the same frame and be invisible to the player.

### Playtesting Results

I did some more playtesting with my partner last night and learned a few things about the game:

1. I need to clarify the pause menu and exit/quit buttons
	- adding a main menu button to the pause menu would be helpful
	- I always call the start menu the main menu instead
2. the ramps and stairs in the maps are not walkable since changing the character controller
	- around the time I switched the player's physics body to the IKCC character controller, the ramps in the church and stairs in front of the church and along the beach are no longer walkable. you can get partway up, then you run out of momentum and slide back down
3. fix stamina usage
	- sometimes stamina is not consumed while sprinting
	- can be consumed if the player is sliding downhill without providing any input on a hill, like the beach
4. the player does not reset on a new game
	- the player's health, inventory, etc do not reset when the new game option is selected
	- add a reset method or find a way to reload the player scene entirely
5. you can throw the rocks at the spooky orbs and they will move around

These were fixed by:

1. [x] a few things:
	1. [x] clarifying the use of "exit" and "quit" on buttons
	2. [x] adding a main menu button to the pause menu
	3. [x] renaming the start menu to be the main menu
2. [x] adjusting the walkable slope to 50 degrees in the IKCC controller
	1. this makes a 45 degree staircase or ramp walkable, but any steeper hills will not be
3. I need to work on reproducing this one, it has been unpredictable
4. [x] I think changing the walkable slope may have unintentionally fixed this as well
	1. I can no longer reproduce the sliding on the beach
	2. if you are sliding down a hill with a slope of more than 50 degrees, losing some stamina while trying to catch yourself makes sense, in my opinion
5. [x] this one is a feature, not a bug
	1. [x] but I might give them a script that applies some upward gravity/buoyancy until they reach a certain height, like their starting height

### Adding a Controls Shortcut to the Pause Menu

I wanted to add a shortcut button to the pause menu that would show you the controls in the options menu, regardless of which menu the options menu was using last time it was visible. Since I have been considering adding a tabbed character menu as well, I thought that having a way to show a menu and select a particular tab would be helpful, even if relying on the tab index might be difficult to maintain if they changed too often.

This was an easy change, with the signatures of a few handlers changing to add a `tab_index` parameter:

```
func _on_menu_changed(menu: ZM_BaseMenu.Menus, tab_index: int = -1) -> void:
	show_menu(menu, tab_index)
```

Which is used when the menu is shown:

```
if m != visible_menu:
	menu_node.hide()

	if menu_node is ZM_BaseMenu:
		menu_node.on_hide()
		menu_node.process_mode = Control.PROCESS_MODE_DISABLED
	else:
		menu_node.process_mode = Control.PROCESS_MODE_INHERIT
		menu_node.show()

		if menu_node is ZM_BaseMenu:
			menu_node.on_show()

		if tab_index > -1:
			if m in tabbed_menus:
				menu_node.active_tab = tab_index
```

The logic could be cleaner, but when the menu is shown, the `tabbed_menus` array is checked. If the menu's key is present, then the `active_tab` property is set. Passing -1 or another negative value causes the last visible tab to be shown again, if the menu has already been shown, or shows the default tab otherwise.

That property can easily be bound to a tab container in the child menu's script:

```
@export var active_tab := 0:
	get():
		return $MarginContainer/VBoxContainer/TabContainer.current_tab
	set(value):
		$MarginContainer/VBoxContainer/TabContainer.current_tab = value
```

This will pass through any reads or writes, exposing the container's property without exposing the node itself. I think you can use this in a tool script to see the tab change in the editor.

### Mixing Foliage Sprites with Texture Packs

There is a great pack of foliage sprites by the prolific game asset creator Kenney, but most of them are in black and white. I was wondering if they could be combined with some of the other texture packs that I have to create some basic sprites for the ground. I'm still working on applying this to a Sprite3D node, which is the eventual goal, but I have a material that combines the two textures on a MeshInstance3D with a simple quad mesh:

![[Pasted image 20251231155117.png]]

The material settings to make that happen:

![[Pasted image 20251231155150.png]]

This multiplies a grass texture by the mask, using the detail texture feature in the material. The triplanar option maps the texture to each side of the cube or quad.

This could be used in a scripted scene to bake sprite images for each combination, if you wanted to sacrifice some disk space, but I think it would perform well enough with the two textures and multiply blending, since that is a fairly simple operation.

### Visible Inventory Items

I wanted to turn the flashlight into an inventory item, but in the current implementation, your inventory items are invisible and excluded from physics to keep them hidden while they follow you around the world.

If I was going to make visible inventory items, they would need markers or slots where they would attach to the player, so that each item or piece of equipment could be designed in the editor at the origin of its own scene, and they would be centered on their slot's marker when the player moved.

This took a few simultaneous changes, including a new component to mark the equipment slot for each equippable item.

All of this effort culminated in the Pretty Princess Sparkle Crown, which leaves a trail of sparkles behind your character:

![[Pasted image 20251231210820.png]]
